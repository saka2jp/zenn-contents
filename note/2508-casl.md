# 認可のデザインパターンの歴史的変遷

認可（authorization）は「誰（主体）が何（操作）をどれ（リソース）に対してできるか」を決める仕組みです。歴史的には、ACL → RBAC → ABAC → ReBAC → PBACという順で発展してきました。以下では、それぞれを「何を基準に決めるのか」「どんなときに強いのか」を平易に整理します。

## ACL（Access Control List）：リソースに紐づく許可表

最初期はシンプルに「リソース側に許可リストを持つ」やり方が主流でした。ファイルならファイルごとに「読める人」「書ける人」を列挙します。直感的でわかりやすい反面、対象が増えるほど表の更新が大変になり、「この人は結局どこにアクセスできるの？」が見えづらくなります。

### ポイント

- 小さなシステムでは簡単で扱いやすい
- 人やリソースが増えると更新・監査が難しくなる

```typescript
// 最小概念：リソースごとの許可表
type UserId = string;
type ResourceId = string;
type Action = 'read' | 'write' | 'delete';

const acl: Record<ResourceId, Record<Action, Set<UserId>>> = {
  'doc:1': {
      read: new Set(['user:alice']),
      write: new Set(['user:alice']),
      delete: new Set()
  },
};

function canACL(user: UserId, action: Action, resource: ResourceId): boolean {
  return !!acl[resource]?.[action]?.has(user);
}

canACL('user:alice', 'read', 'doc:1'); // true
canACL('user:alice', 'read', 'doc:2'); // false
canACL('user:alice', 'delete', 'doc:1') // false
```

## RBAC（Role-Based Access Control）：役割でまとめて付与

大規模化で ACL が破綻しがちになると、「役割（ロール）」を挟む方式が広まりました。ユーザーはロールを持ち、ロールに権限がぶら下がります。入社・異動・退職の運用と相性が良く、監査や職務分離（SoD）にも向きます。ただし「条件つき（時間帯・場所・一時委譲など）」には弱く、ロールが増えすぎる"ロール爆発"が起きがちです。

### ポイント

- ユーザー→ロール→権限の間接付与で運用が楽
- 条件付きの権限管理に対応しにくい
- ロールが増えやすい

```typescript
// 最小概念：ロールに権限、ユーザーにロール
type Permission = `${string}:${'read'|'write'|'delete'}`;
const rolePermissions: Record<string, Permission[]> = {
  Admin: ['document:read', 'document:write', 'document:delete'],
  Viewer: ['document:read'],
};

const userRoles: Record<UserId, string[]> = {
  'user:alice': ['Admin'],
  'user:bob': ['Viewer'],
};

function canRBAC(user: UserId, perm: Permission): boolean {
  return (userRoles[user] ?? []).some(role => rolePermissions[role]?.includes(perm));
}

canRBAC('user:alice', 'document:delete'); // true
canRBAC('user:bob', 'document:delete') // false
```

## ABAC（Attribute-Based Access Control）：属性と条件で決める

次に登場したのが **属性（attribute）** による判定です。主体（ユーザー）の属性、リソースの属性、環境（時間帯・IP・デバイス）などを条件式で評価します。たとえば「同じ部門かつ平日9–18時なら編集可」といった文脈を取り込むことができます。柔軟ですが、ポリシー（条件）の作り方と運用が難しくなります。

### ポイント

- 条件の表現力が高く、複雑な条件に対応可能
- ポリシーが増えると保守運用の難易度が高くなる

```typescript
// 最小概念：属性ベースのポリシー
type User = { id: string; groupId: string }
type Doc  = { id: string; ownerId: string; groupId: string; classification: 'public'|'internal'|'secret' };
type Action = 'read' | 'write' | 'delete';

type ABACPolicy = (now: Date, user: User, action: Action, doc: Doc) => boolean;
const abacPolicies: ABACPolicy[] = [
  // 所有者は全操作OK
  (now, user, action, doc) => doc.ownerId === user.Id,
  // 同じ部門なら勤務時間（9-18）内の編集可
  (now, user, action, doc) => action === 'write' && user.groupId === doc.groupId && now.getHours() >= 9 && now.getHours() < 18,
  // 公開文書は誰でも読める
  (now, user, action, doc) => action === 'read' && doc.classification === 'public',
];

function canABAC(now:Date, userId: string, action: Action, doc: Doc): boolean {
  // すべての必須条件を満たす（例として AND で評価）
  return abacPolicies.every(p => p(now, userId, action, doc));
}

canABAC(new Date(), { id: 'user:alice', groupId: 'group:dev' }, 'write', { id: 'doc:1', ownerId: 'user:alice', groupId: 'group:dev', classification: 'public' }); // true
canABAC(new Date(), { id: 'user:bob', groupId: 'group:dev' }, 'write', { id: 'doc:1', ownerId: 'user:alice', groupId: 'group:dev', classification: 'public' }); // true
canABAC(new Date(), { id: 'user:carol' groupId: 'group:biz' }, 'write', { id: 'doc:1', ownerId: 'user:alice', groupId: 'group:dev', classification: 'public' }); // false
```

## ReBAC（Relationship-Based Access Control）：関係グラフで表す
SaaS の「共有」「委譲」「フォルダ階層」などが一般化すると、**関係（relationship）** そのものを記録して判定する ReBAC が注目されます。ユーザーとリソースのグ
ラフを辿り、「編集者」「所属グループのメンバー」「親フォルダの権限を継承」といった関係で可否を決めます。コラボレーションに強い一方、関係が深くなるとクエリと運用
が複雑化します。

ReBAC をフルスクラッチで書くのは **関係ストアの設計やクエリの最適化** が難題です。そこで登場した OSS が **[OpenFGA](https://openfga.dev/)** です。Google Zanzibar 論文を下敷きにしたスキーマ（authorization model）とリレーショナルデータを Tuple で保存し、アクセス判定を行うサーバー/SDK を提供します。

ポイントは次のとおりです。

1. **宣言的スキーマ**: `type` と `relation` を DSL で定義し、グラフの推論ルール（継承・委譲・ロールなど）を書ける。
2. **水平スケール**: Datastore として DynamoDB や Postgres 等を選択でき、大規模コラボ SaaS でも使われている。
3. **マルチ SDK**: Go/TS/Python などの SDK があり、アプリ側は `check` を呼ぶだけで済む。

以下は **TypeScript SDK (`@openfga/sdk`)** で「ドキュメント共有」シナリオを最小構成で動かす例です。

```typescript
import { OpenFgaClient, CredentialsMethod } from '@openfga/sdk';

// 1. OpenFGA インスタンスへ接続
const fga = new OpenFgaClient({
  apiUrl: process.env.FGA_API_URL,
  storeId: process.env.FGA_STORE_ID,
});

// 2. Authorization Model を宣言
await fga.writeAuthorizationModel({
  type_definitions: [
    { type: 'user' },
    {
      type: 'group',
      relations: {
        member: { this: {} }, // group#member
      },
    },
    {
      type: 'document',
      relations: {
        // ドキュメント所有者
        owner: { this: {} },
        // editor は owner または group#member に継承
        editor: {
          union: {
            child: [
              { this: {} }, // document#editor
              { relation: 'owner' }, // document#owner
              { computedUserset: { type: 'group', relation: 'member' } }, // group#member
            ],
          },
        },
        // viewer は editor などから継承
        viewer: {
          union: {
            child: [
              { this: {} },
              { relation: 'editor' },
              { relation: 'owner' },
            ],
          },
        },
      },
    },
  ],
});

// 3. Tuple (関係エッジ) を書き込む
await fga.write({
  writes: {
    tuples: [
      { user: 'user:alice', relation: 'owner', object: 'document:1' },
      { group: 'group:dev', relation: 'editor', object: 'document:1' },
      { user: 'user:bob', relation: 'member', object: 'group:dev' },
      { user: 'user:carol', relation: 'member', object: 'group:biz' },
    ],
  },
});

await fga.check({user: 'user:alice', relation: 'owner', object: 'document:1'}) // true
await fga.check({user: 'user:bob', relation: 'viewer', object: 'document:1'}); // true
await fga.check({user: 'user:bob', relation: 'owner', object: 'document:1'}) // true
```

上記では **ReBAC のグラフ推論（継承・委譲・グループメンバーシップ）** をすべて OpenFGA に任せ、アプリ側は `check` API を呼ぶだけで済むのが大きな利点です。
ただし、OpenFGAにデータを同期するが必要があるため、

## PBAC（Policy-Based Access Control）：ポリシーを外部化して一元管理

最後に、モデル（RBAC/ABAC/ReBAC）を問わず、「ルール＝ポリシー」を外部の評価エンジンで一元管理する発想が PBAC です。アプリは PEP（Enforcement）として「このリクエスト許可していい？」とPDP（Decision）に問い合わせ、PDP はポリシーに従って許可/拒否を返します。マイクロサービス横断で同じルールを回せる利点があり、運用は外部化されます。構成は「サイドカー/別サーバーに PDP を置く」「SDK でローカル評価する」など複数あります。

### ポイント

- ルールをコード（DSL）として集中管理でき、監査・テスト・リリースに組み込める
- レイテンシや可用性、ポリシー言語の学習など運用設計がカギ

```typescript
// 最小概念：PEP（アプリ）⇔ PDP（評価エンジン）の分離
type DecisionRequest = {
  principal: { id: UserId; groups: string[]; dept: string; tenantId: string };
  action: Action;
  resource: { id: ResourceId; ownerId: UserId; dept: string; tenantId: string; classification: string };
  context: { now: string; deviceTrusted: boolean };
};
type DecisionResult = { allow: boolean; reason?: string };

// PEP：アプリ側（実際はHTTPやgRPCでPDPへ問い合わせる想定）
async function pepAuthorize(req: DecisionRequest): Promise<DecisionResult> {
  // ここでは同プロセスで疑似的に呼ぶ（実運用は外部サービスやSDK）
  return pdpEvaluate(req);
}

// PDP：外部化された評価（ここでは簡易関数・本来はRego/Cedar等のDSLで表現）
function pdpEvaluate(req: DecisionRequest): DecisionResult {
  const { principal, resource, action, context } = req;

  // 例1: マルチテナント境界
  if (principal.tenantId !== resource.tenantId) return { allow: false, reason: 'cross-tenant' };

  // 例2: ReBAC的（所有者は全操作OK）
  if (principal.id === resource.ownerId) return { allow: true, reason: 'owner' };

  // 例3: RBAC的（グループ=Managers は同部門の閲覧可）
  if (action === 'read' && principal.groups.includes('Managers') && principal.dept === resource.dept) {
    return { allow: true, reason: 'manager-same-dept' };
  }

  // 例4: ABAC的（編集は信頼端末＆業務時間）
  const hour = new Date(context.now).getHours();
  if (action === 'write' && context.deviceTrusted && hour >= 9 && hour < 18 && principal.dept === resource.dept) {
    return { allow: true, reason: 'abac-window' };
  }

  // 例5: 公開文書は閲覧OK
  if (action === 'read' && resource.classification === 'public') {
    return { allow: true, reason: 'public' };
  }

  return { allow: false, reason: 'no-policy' };
}
```

> **補足**：上の `pdpEvaluate` は説明用の擬似コードです。実際は OPA（Rego）やCedarなどのポリシー言語にルールを書き、外部の PDP で評価します。アプリ（PEP）はリクエストの事実情報（principal / action / resource / context）だけを渡し、判断は外部に"任せる"のが PBAC の肝です。

## まとめ

- **ACL** は「リソースについた許可表」で始まり、シンプルだが拡張に弱い。
- **RBAC** は「役割」を介して運用を安定化させるが、文脈に弱い。
- **ABAC** は「属性と条件」で文脈を扱い、ゼロトラスト時代に適合するが、運用設計が要る。
- **ReBAC** は「関係グラフ」で共有・委譲・継承を自然に表現でき、コラボ機能に強い。
- **PBAC** は「ポリシーを外部化」してモデル横断に一元管理でき、マイクロサービスや全社統制に向く。

それぞれの強みは異なります。業務の"主語"が何か（リソース単位か、役割運用か、文脈か、関係か、ポリシー集中管理か）を見極め、必要に応じて組み合わせるのが実践的です。必要であれば、あなたのユースケース（マルチテナント境界、共有・委譲の複雑さ、監査要件、サービス数）を前提に、より具体的な設計案に落とし込みます。
