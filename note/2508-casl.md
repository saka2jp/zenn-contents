# 認可のデザインパターンの歴史的変遷

認可（authorization）は「誰（主体）が何（操作）をどれ（リソース）に対してできるか」を決める仕組みです。歴史的には、ACL → RBAC → ABAC → ReBAC → PBACという順で発展してきました。以下では、それぞれを「何を基準に決めるのか」「どんなときに強いのか」を平易に整理します。

## ACL（Access Control List）：リソースに紐づく許可表

最初期はシンプルに「リソース側に許可リストを持つ」やり方が主流でした。ファイルならファイルごとに「読める人」「書ける人」を列挙します。直感的でわかりやすい反面、対象が増えるほど表の更新が大変になり、「この人は結局どこにアクセスできるの？」が見えづらくなります。

### ポイント

- 小さなシステムでは簡単で扱いやすい
- 人やリソースが増えると更新・監査が難しくなる

```typescript
// 最小概念：リソースごとの許可表
type UserId = string;
type ResourceId = string;
type Action = 'read' | 'write' | 'delete';

const acl: Record<ResourceId, Record<Action, Set<UserId>>> = {
  'doc:1': {
      read: new Set(['user:alice']),
      write: new Set(['user:alice']),
      delete: new Set()
  },
};

function canACL(user: UserId, action: Action, resource: ResourceId): boolean {
  return !!acl[resource]?.[action]?.has(user);
}

canACL('user:alice', 'read', 'doc:1'); // true
canACL('user:alice', 'read', 'doc:2'); // false
canACL('user:alice', 'delete', 'doc:1') // false
```

## RBAC（Role-Based Access Control）：役割でまとめて付与

大規模化で ACL が破綻しがちになると、「役割（ロール）」を挟む方式が広まりました。ユーザーはロールを持ち、ロールに権限がぶら下がります。入社・異動・退職の運用と相性が良く、監査や職務分離（SoD）にも向きます。ただし「条件つき（時間帯・場所・一時委譲など）」には弱く、ロールが増えすぎる"ロール爆発"が起きがちです。

### ポイント

- ユーザー→ロール→権限の間接付与で運用が楽
- 条件付きの権限管理に対応しにくい
- ロールが増えやすい

```typescript
// 最小概念：ロールに権限、ユーザーにロール
type Permission = `${string}:${'read'|'write'|'delete'}`;
const rolePermissions: Record<string, Permission[]> = {
  Admin: ['document:read', 'document:write', 'document:delete'],
  Viewer: ['document:read'],
};

const userRoles: Record<UserId, string[]> = {
  'user:alice': ['Admin'],
  'user:bob': ['Viewer'],
};

function canRBAC(user: UserId, perm: Permission): boolean {
  return (userRoles[user] ?? []).some(role => rolePermissions[role]?.includes(perm));
}

canRBAC('user:alice', 'document:delete'); // true
canRBAC('user:bob', 'document:delete') // false
```

## ABAC（Attribute-Based Access Control）：属性と条件で決める

次に登場したのが **属性（attribute）** による判定です。主体（ユーザー）の属性、リソースの属性、環境（時間帯・IP・デバイス）などを条件式で評価します。たとえば「同じ部門かつ平日9–18時なら編集可」といった文脈を取り込むことができます。柔軟ですが、ポリシー（条件）の作り方と運用が難しくなります。

### ポイント

- 条件の表現力が高く、複雑な条件に対応可能
- ポリシーが増えると保守運用の難易度が高くなる

```typescript
// 最小概念：属性ベースのポリシー
type User = { id: string; groupId: string }
type Doc  = { id: string; ownerId: string; groupId: string; };
type Action = 'read' | 'write' | 'delete';

type ABACPolicy = (now: Date, user: User, action: Action, doc: Doc) => boolean;
const abacPolicies: ABACPolicy[] = [
  // 所有者は全操作OK
  (now, user, action, doc) => doc.ownerId === user.id,
  // 同じ部門なら勤務時間（9-18）内の編集可
  (now, user, action, doc) => action === 'write' && user.groupId === doc.groupId && now.getHours() >= 9 && now.getHours() < 18,
];

function canABAC(now: Date, user: User, action: Action, doc: Doc): boolean {
  // すべての必須条件を満たす（例として AND で評価）
  return abacPolicies.every(p => p(now, user, action, doc));
}

canABAC(new Date(), { id: 'user:alice', groupId: 'group:dev' }, 'write', { id: 'doc:1', ownerId: 'user:alice', groupId: 'group:dev' }); // true
canABAC(new Date(), { id: 'user:bob', groupId: 'group:dev' }, 'write', { id: 'doc:1', ownerId: 'user:alice', groupId: 'group:dev' }); // true
canABAC(new Date(), { id: 'user:carol', groupId: 'group:biz' }, 'write', { id: 'doc:1', ownerId: 'user:alice', groupId: 'group:dev' }); // false
```

## ReBAC（Relationship-Based Access Control）：関係グラフで表す
SaaS の「共有」「委譲」「フォルダ階層」などが一般化すると、**関係（relationship）** そのものを記録して判定する ReBAC が注目されます。ユーザーとリソースのグ
ラフを辿り、「編集者」「所属グループのメンバー」「親フォルダの権限を継承」といった関係で可否を決めます。コラボレーションに強い一方、関係が深くなるとクエリと運用
が複雑化します。

ReBAC をフルスクラッチで書くのは **関係ストアの設計やクエリの最適化** が難題です。そこで登場した OSS が **[OpenFGA](https://openfga.dev/)** です。Google Zanzibar 論文を下敷きにしたスキーマ（authorization model）とリレーショナルデータを Tuple で保存し、アクセス判定を行うサーバー/SDK を提供します。

ポイントは次のとおりです。

1. **宣言的スキーマ**: `type` と `relation` を DSL で定義し、グラフの推論ルール（継承・委譲・ロールなど）を書ける。
2. **水平スケール**: Datastore として DynamoDB や Postgres 等を選択でき、大規模コラボ SaaS でも使われている。
3. **マルチ SDK**: Go/TS/Python などの SDK があり、アプリ側は `check` を呼ぶだけで済む。

以下は **TypeScript SDK (`@openfga/sdk`)** で「ドキュメント共有」シナリオを最小構成で動かす例です。

```typescript
import { OpenFgaClient, CredentialsMethod } from '@openfga/sdk';

// 1. OpenFGA インスタンスへ接続
const fga = new OpenFgaClient({
  apiUrl: process.env.FGA_API_URL,
  storeId: process.env.FGA_STORE_ID,
});

// 2. Authorization Model を宣言
await fga.writeAuthorizationModel({
  type_definitions: [
    { type: 'user' },
    {
      type: 'group',
      relations: {
        member: { this: {} }, // group#member
      },
    },
    {
      type: 'document',
      relations: {
        // ドキュメント所有者
        owner: { this: {} },
        // editor は owner または group#member に継承
        editor: {
          union: {
            child: [
              { this: {} }, // document#editor
              { relation: 'owner' }, // document#owner
              { computedUserset: { type: 'group', relation: 'member' } }, // group#member
            ],
          },
        },
        // viewer は editor などから継承
        viewer: {
          union: {
            child: [
              { this: {} },
              { relation: 'editor' },
              { relation: 'owner' },
            ],
          },
        },
      },
    },
  ],
});

// 3. Tuple (関係エッジ) を書き込む
await fga.write({
  writes: {
    tuples: [
      { user: 'user:alice', relation: 'owner', object: 'document:1' },
      { group: 'group:dev', relation: 'editor', object: 'document:1' },
      { user: 'user:bob', relation: 'member', object: 'group:dev' },
      { user: 'user:carol', relation: 'member', object: 'group:biz' },
    ],
  },
});

await fga.check({user: 'user:alice', relation: 'owner', object: 'document:1'}) // true
await fga.check({user: 'user:bob', relation: 'viewer', object: 'document:1'}); // true
await fga.check({user: 'user:bob', relation: 'owner', object: 'document:1'}) // false
```

上記では **ReBAC のグラフ推論（継承・委譲・グループメンバーシップ）** をすべて OpenFGA に任せ、アプリ側は `check` API を呼ぶだけで済むのが大きな利点です。
ただし、OpenFGA にデータを同期する必要があるため、

## PBAC（Policy-Based Access Control）：ポリシーを外部化して一元管理

最後に、モデル（RBAC/ABAC/ReBAC）を問わず、「ルール＝ポリシー」を外部の評価エンジンで一元管理する発想が PBAC です。アプリは PEP（Enforcement）として「このリクエスト許可していい？」とPDP（Decision）に問い合わせ、PDP はポリシーに従って許可/拒否を返します。マイクロサービス横断で同じルールを回せる利点があり、運用は外部化されます。構成は「サイドカー/別サーバーに PDP を置く」「SDK でローカル評価する」など複数あります。

### ポイント

- ルールをコード（DSL）として集中管理でき、監査・テスト・リリースに組み込める
- レイテンシや可用性、ポリシー言語の学習など運用設計がカギ

### 代表例：AWS IAM（マネージド PBAC）

AWS の IAM は、クラウド全体で統一された PBAC の代表例です。各 AWS サービスの API フロントが PEP、IAM が PDP として振る舞い、JSON ベースのポリシーに基づき許可/拒否を決定します。

この構成は、PBAC の典型である PEP/PDP/PIP の分離（PIP＝タグや組織情報などの属性提供）を体現しています。アプリケーション内で PBAC を適用する場合は、同様の発想で OPA（Rego）や Cedar（Amazon Verified Permissions）などのエンジンを PDP として採用するのが一般的です。

#### サンプル: アイデンティティベースポリシー（タグによる ABAC）

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "ReadProjectTaggedObjects",
      "Effect": "Allow",
      "Action": [
        "s3:GetObject"
      ],
      "Resource": "arn:aws:s3:::my-app-data/*",
      "Condition": {
        "StringEquals": {
          "s3:ExistingObjectTag/Project": "${aws:PrincipalTag/Project}"
        }
      }
    }
  ]
}
```

## まとめ

- **ACL** は「リソースについた許可表」で始まり、シンプルだが拡張に弱い。
- **RBAC** は「役割」を介して運用を安定化させるが、文脈に弱い。
- **ABAC** は「属性と条件」で文脈を扱い、運用設計が要る。
- **ReBAC** は「関係グラフ」で共有・委譲・継承を自然に表現可能。
- **PBAC** は「ポリシーを外部化」してモデル横断に一元管理でき、マイクロサービスや全社統制に向く。

それぞれの強みは異なります。業務の"主語"が何か（リソース単位か、役割運用か、文脈か、関係か、ポリシー集中管理か）を見極め、必要に応じて組み合わせるのが実践的です。必要であれば、あなたのユースケース（マルチテナント境界、共有・委譲の複雑さ、監査要件、サービス数）を前提に、より具体的な設計案に落とし込みます。

## CASL：アプリ内の宣言的認可ライブラリ

CASL は JavaScript/TypeScript 向けの認可ライブラリで、アプリケーション内で「誰が（action）何に（subject）対して、どんな条件なら（conditions）できるか」を宣言的に表現・評価します。外部 PDP を置く PBAC とは異なり、アプリ（PEP）側で軽量にルールを評価するため、UI の出し分けから API レベルのガードまで同じルールで統一しやすいのが特徴です。

### 特徴

- クライアント/サーバ双方で動作し、ルールのシリアライズ/共有が容易
- 宣言的 DSL：`can`/`cannot` によるアクション・サブジェクト・条件の定義
- フィールドレベル制御（特定フィールドの表示・編集可否）
- 主要エコシステム連携：`@casl/react`、`@casl/vue`、`@casl/angular`、`@casl/prisma`、`@casl/mongoose` など

### 最小サンプル（TypeScript）

```typescript
import { AbilityBuilder, createMongoAbility, MongoAbility } from '@casl/ability';

type Actions = 'manage' | 'read' | 'create' | 'update' | 'delete';
type Subjects = 'Article' | 'User' | 'all';

type AppAbility = MongoAbility<[Actions, Subjects]>;

function defineAbilityFor(userId: string): AppAbility {
  const { can, cannot, build } = new AbilityBuilder<AppAbility>(createMongoAbility);

  can('read', 'Article');
  can('update', 'Article', { authorId: userId });
  cannot('delete', 'Article', { published: true });

  return build({
    detectSubjectType: (subject) =>
      typeof subject === 'string'
        ? subject
        : (subject as any)?.type ?? 'all',
  });
}

const ability = defineAbilityFor('user:alice');
ability.can('update', 'Article', { authorId: 'user:alice' }); // true
ability.can('delete', 'Article', { published: true }); // false
```

### 実装

- リクエスト単位で Ability を生成し、UI と API の双方で同じ Ability を用いてガードする
- DB 取得前のアクセス制御には、ORM 連携（例：`@casl/prisma`）のクエリヘルパーでフィルタリング
